--- libx86-1.1/x86emu/x86emu/debug.h.SAVE	2006-10-29 20:31:05.000000000 +0300
+++ libx86-1.1/x86emu/x86emu/debug.h	2009-04-12 13:15:34.000000000 +0400
@@ -49,10 +49,10 @@
 #define CHECK_DATA_ACCESS_F             0x8 /*using segment:offset*/
 
 #ifdef DEBUG
-# define CHECK_IP_FETCH()              	(M.x86.check & CHECK_IP_FETCH_F)
-# define CHECK_SP_ACCESS()             	(M.x86.check & CHECK_SP_ACCESS_F)
-# define CHECK_MEM_ACCESS()            	(M.x86.check & CHECK_MEM_ACCESS_F)
-# define CHECK_DATA_ACCESS()           	(M.x86.check & CHECK_DATA_ACCESS_F)
+# define CHECK_IP_FETCH()              	(1)
+# define CHECK_SP_ACCESS()             	(1)
+# define CHECK_MEM_ACCESS()            	(1)
+# define CHECK_DATA_ACCESS()           	(1)
 #else
 # define CHECK_IP_FETCH()
 # define CHECK_SP_ACCESS()
@@ -61,24 +61,24 @@
 #endif
 
 #ifdef DEBUG
-# define DEBUG_INSTRUMENT()    	(M.x86.debug & DEBUG_INSTRUMENT_F)
-# define DEBUG_DECODE()        	(M.x86.debug & DEBUG_DECODE_F)
-# define DEBUG_TRACE()         	(M.x86.debug & DEBUG_TRACE_F)
-# define DEBUG_STEP()          	(M.x86.debug & DEBUG_STEP_F)
-# define DEBUG_DISASSEMBLE()   	(M.x86.debug & DEBUG_DISASSEMBLE_F)
-# define DEBUG_BREAK()         	(M.x86.debug & DEBUG_BREAK_F)
-# define DEBUG_SVC()           	(M.x86.debug & DEBUG_SVC_F)
-# define DEBUG_SAVE_IP_CS()     (M.x86.debug & DEBUG_SAVE_IP_CS_F)
-
-# define DEBUG_FS()            	(M.x86.debug & DEBUG_FS_F)
-# define DEBUG_PROC()          	(M.x86.debug & DEBUG_PROC_F)
-# define DEBUG_SYSINT()        	(M.x86.debug & DEBUG_SYSINT_F)
-# define DEBUG_TRACECALL()     	(M.x86.debug & DEBUG_TRACECALL_F)
-# define DEBUG_TRACECALLREGS() 	(M.x86.debug & DEBUG_TRACECALL_REGS_F)
-# define DEBUG_SYS()           	(M.x86.debug & DEBUG_SYS_F)
-# define DEBUG_MEM_TRACE()     	(M.x86.debug & DEBUG_MEM_TRACE_F)
-# define DEBUG_IO_TRACE()      	(M.x86.debug & DEBUG_IO_TRACE_F)
-# define DEBUG_DECODE_NOPRINT() (M.x86.debug & DEBUG_DECODE_NOPRINT_F)
+# define DEBUG_INSTRUMENT()    	(1)
+# define DEBUG_DECODE()        	(1)
+# define DEBUG_TRACE()         	(1)
+# define DEBUG_STEP()          	(1)
+# define DEBUG_DISASSEMBLE()   	(0)
+# define DEBUG_BREAK()         	(1)
+# define DEBUG_SVC()           	(1)
+# define DEBUG_SAVE_IP_CS()     (1)
+
+# define DEBUG_FS()            	(1)
+# define DEBUG_PROC()          	(1)
+# define DEBUG_SYSINT()        	(1)
+# define DEBUG_TRACECALL()     	(1)
+# define DEBUG_TRACECALLREGS() 	(1)
+# define DEBUG_SYS()           	(1)
+# define DEBUG_MEM_TRACE()     	(1)
+# define DEBUG_IO_TRACE()      	(1)
+# define DEBUG_DECODE_NOPRINT() (1)
 #else
 # define DEBUG_INSTRUMENT()    	0
 # define DEBUG_DECODE()        	0
--- libx86-1.1/Makefile.SAVE	2009-04-12 12:49:18.000000000 +0400
+++ libx86-1.1/Makefile	2009-04-12 13:52:25.000000000 +0400
@@ -1,5 +1,6 @@
 OBJECTS = x86-common.o
 CFLAGS ?= -O2 -Wall -DDEBUG -g
+CFLAGS += -O0 -DDEBUG -g
 LIBDIR ?= /usr/lib
 
 ifeq ($(BACKEND),x86emu)
--- libx86-1.1/x86emu/ops.c.SAVE	2006-10-30 23:11:13.000000000 +0300
+++ libx86-1.1/x86emu/ops.c	2009-04-12 15:06:19.000000000 +0400
@@ -73,6 +73,13 @@
 
 #include "x86emu/x86emui.h"
 
+#include <stdio.h>
+#define DprintLn(fmt, args...) \
+    do { \
+       fprintf(stderr, "[%s:%u:%s] " fmt "\n", __FUNCTION__, __LINE__, __FILE__, ##args); \
+       fflush(stderr); \
+    } while (0)
+
 /*----------------------------- Implementation ----------------------------*/
 
 /****************************************************************************
@@ -85,6 +92,7 @@
 static void x86emuOp_illegal_op(
     u8 op1)
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("ILLEGAL X86 OPCODE\n");
     TRACE_REGS();
@@ -105,6 +113,7 @@
     u8 *destreg, *srcreg;
     u8 destval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("ADD\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -161,6 +170,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("ADD\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -283,6 +293,7 @@
     uint srcoffset;
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("ADD\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -336,6 +347,7 @@
     int mod, rl, rh;
     uint srcoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("ADD\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -449,6 +461,7 @@
 {
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("ADD\tAL,");
     srcval = fetch_byte_imm();
@@ -467,6 +480,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("ADD\tEAX,");
@@ -492,6 +506,7 @@
 ****************************************************************************/
 static void x86emuOp_push_ES(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("PUSH\tES\n");
     TRACE_AND_STEP();
@@ -506,6 +521,7 @@
 ****************************************************************************/
 static void x86emuOp_pop_ES(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("POP\tES\n");
     TRACE_AND_STEP();
@@ -525,6 +541,7 @@
     uint destoffset;
     u8 destval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("OR\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -581,6 +598,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("OR\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -703,6 +721,7 @@
     uint srcoffset;
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("OR\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -756,6 +775,7 @@
     int mod, rl, rh;
     uint srcoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("OR\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -869,6 +889,7 @@
 {
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("OR\tAL,");
     srcval = fetch_byte_imm();
@@ -887,6 +908,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("OR\tEAX,");
@@ -912,6 +934,7 @@
 ****************************************************************************/
 static void x86emuOp_push_CS(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("PUSH\tCS\n");
     TRACE_AND_STEP();
@@ -926,7 +949,10 @@
 ****************************************************************************/
 static void x86emuOp_two_byte(u8 X86EMU_UNUSED(op1))
 {
-    u8 op2 = (*sys_rdb)(((u32)M.x86.R_CS << 4) + (M.x86.R_IP++));
+//  u8 op2 = (*sys_rdb)(((u32)M.x86.R_CS << 4) + (M.x86.R_IP++));
+    u8 op2;
+    DprintLn("");
+    op2 = (*sys_rdb)(((u32)M.x86.R_CS << 4) + (M.x86.R_IP++));
     INC_DECODED_INST_LEN(1);
     (*x86emu_optab2[op2])(op2);
 }
@@ -942,6 +968,7 @@
     uint destoffset;
     u8 destval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("ADC\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -998,6 +1025,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("ADC\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -1120,6 +1148,7 @@
     uint srcoffset;
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("ADC\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -1173,6 +1202,7 @@
     int mod, rl, rh;
     uint srcoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("ADC\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -1286,6 +1316,7 @@
 {
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("ADC\tAL,");
     srcval = fetch_byte_imm();
@@ -1304,6 +1335,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("ADC\tEAX,");
@@ -1329,6 +1361,7 @@
 ****************************************************************************/
 static void x86emuOp_push_SS(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("PUSH\tSS\n");
     TRACE_AND_STEP();
@@ -1343,6 +1376,7 @@
 ****************************************************************************/
 static void x86emuOp_pop_SS(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("POP\tSS\n");
     TRACE_AND_STEP();
@@ -1362,6 +1396,7 @@
     uint destoffset;
     u8 destval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("SBB\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -1418,6 +1453,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("SBB\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -1540,6 +1576,7 @@
     uint srcoffset;
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("SBB\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -1593,6 +1630,7 @@
     int mod, rl, rh;
     uint srcoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("SBB\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -1706,6 +1744,7 @@
 {
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("SBB\tAL,");
     srcval = fetch_byte_imm();
@@ -1724,6 +1763,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("SBB\tEAX,");
@@ -1749,6 +1789,7 @@
 ****************************************************************************/
 static void x86emuOp_push_DS(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("PUSH\tDS\n");
     TRACE_AND_STEP();
@@ -1763,6 +1804,7 @@
 ****************************************************************************/
 static void x86emuOp_pop_DS(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("POP\tDS\n");
     TRACE_AND_STEP();
@@ -1782,6 +1824,7 @@
     uint destoffset;
     u8 destval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("AND\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -1842,6 +1885,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("AND\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -1964,6 +2008,7 @@
     uint srcoffset;
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("AND\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -2017,6 +2062,7 @@
     int mod, rl, rh;
     uint srcoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("AND\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -2131,6 +2177,7 @@
 {
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("AND\tAL,");
     srcval = fetch_byte_imm();
@@ -2149,6 +2196,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("AND\tEAX,");
@@ -2174,6 +2222,7 @@
 ****************************************************************************/
 static void x86emuOp_segovr_ES(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("ES:\n");
     TRACE_AND_STEP();
@@ -2191,6 +2240,7 @@
 ****************************************************************************/
 static void x86emuOp_daa(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("DAA\n");
     TRACE_AND_STEP();
@@ -2210,6 +2260,7 @@
     uint destoffset;
     u8 destval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("SUB\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -2266,6 +2317,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("SUB\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -2388,6 +2440,7 @@
     uint srcoffset;
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("SUB\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -2441,6 +2494,7 @@
     int mod, rl, rh;
     uint srcoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("SUB\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -2554,6 +2608,7 @@
 {
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("SUB\tAL,");
     srcval = fetch_byte_imm();
@@ -2572,6 +2627,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("SUB\tEAX,");
@@ -2597,6 +2653,7 @@
 ****************************************************************************/
 static void x86emuOp_segovr_CS(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("CS:\n");
     TRACE_AND_STEP();
@@ -2611,6 +2668,7 @@
 ****************************************************************************/
 static void x86emuOp_das(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("DAS\n");
     TRACE_AND_STEP();
@@ -2630,6 +2688,7 @@
     uint destoffset;
     u8 destval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("XOR\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -2686,6 +2745,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("XOR\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -2808,6 +2868,7 @@
     uint srcoffset;
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("XOR\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -2861,6 +2922,7 @@
     int mod, rl, rh;
     uint srcoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("XOR\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -2974,6 +3036,7 @@
 {
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("XOR\tAL,");
     srcval = fetch_byte_imm();
@@ -2992,6 +3055,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XOR\tEAX,");
@@ -3017,6 +3081,7 @@
 ****************************************************************************/
 static void x86emuOp_segovr_SS(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("SS:\n");
     TRACE_AND_STEP();
@@ -3031,6 +3096,7 @@
 ****************************************************************************/
 static void x86emuOp_aaa(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("AAA\n");
     TRACE_AND_STEP();
@@ -3050,6 +3116,7 @@
     u8 *destreg, *srcreg;
     u8 destval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("CMP\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -3103,6 +3170,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("CMP\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -3219,6 +3287,7 @@
     uint srcoffset;
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("CMP\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -3272,6 +3341,7 @@
     int mod, rl, rh;
     uint srcoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("CMP\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -3385,6 +3455,7 @@
 {
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("CMP\tAL,");
     srcval = fetch_byte_imm();
@@ -3403,6 +3474,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("CMP\tEAX,");
@@ -3428,6 +3500,7 @@
 ****************************************************************************/
 static void x86emuOp_segovr_DS(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("DS:\n");
     TRACE_AND_STEP();
@@ -3442,6 +3515,7 @@
 ****************************************************************************/
 static void x86emuOp_aas(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("AAS\n");
     TRACE_AND_STEP();
@@ -3456,6 +3530,7 @@
 ****************************************************************************/
 static void x86emuOp_inc_AX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tEAX\n");
@@ -3478,6 +3553,7 @@
 ****************************************************************************/
 static void x86emuOp_inc_CX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tECX\n");
@@ -3500,6 +3576,7 @@
 ****************************************************************************/
 static void x86emuOp_inc_DX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tEDX\n");
@@ -3522,6 +3599,7 @@
 ****************************************************************************/
 static void x86emuOp_inc_BX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tEBX\n");
@@ -3544,6 +3622,7 @@
 ****************************************************************************/
 static void x86emuOp_inc_SP(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tESP\n");
@@ -3566,6 +3645,7 @@
 ****************************************************************************/
 static void x86emuOp_inc_BP(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tEBP\n");
@@ -3588,6 +3668,7 @@
 ****************************************************************************/
 static void x86emuOp_inc_SI(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tESI\n");
@@ -3610,6 +3691,7 @@
 ****************************************************************************/
 static void x86emuOp_inc_DI(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tEDI\n");
@@ -3632,6 +3714,7 @@
 ****************************************************************************/
 static void x86emuOp_dec_AX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tEAX\n");
@@ -3654,6 +3737,7 @@
 ****************************************************************************/
 static void x86emuOp_dec_CX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tECX\n");
@@ -3676,6 +3760,7 @@
 ****************************************************************************/
 static void x86emuOp_dec_DX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tEDX\n");
@@ -3698,6 +3783,7 @@
 ****************************************************************************/
 static void x86emuOp_dec_BX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tEBX\n");
@@ -3720,6 +3806,7 @@
 ****************************************************************************/
 static void x86emuOp_dec_SP(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tESP\n");
@@ -3742,6 +3829,7 @@
 ****************************************************************************/
 static void x86emuOp_dec_BP(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tEBP\n");
@@ -3764,6 +3852,7 @@
 ****************************************************************************/
 static void x86emuOp_dec_SI(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tESI\n");
@@ -3786,6 +3875,7 @@
 ****************************************************************************/
 static void x86emuOp_dec_DI(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tEDI\n");
@@ -3808,6 +3898,7 @@
 ****************************************************************************/
 static void x86emuOp_push_AX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tEAX\n");
@@ -3830,6 +3921,7 @@
 ****************************************************************************/
 static void x86emuOp_push_CX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tECX\n");
@@ -3852,6 +3944,7 @@
 ****************************************************************************/
 static void x86emuOp_push_DX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tEDX\n");
@@ -3874,6 +3967,7 @@
 ****************************************************************************/
 static void x86emuOp_push_BX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tEBX\n");
@@ -3896,6 +3990,7 @@
 ****************************************************************************/
 static void x86emuOp_push_SP(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tESP\n");
@@ -3922,6 +4017,7 @@
 ****************************************************************************/
 static void x86emuOp_push_BP(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tEBP\n");
@@ -3944,6 +4040,7 @@
 ****************************************************************************/
 static void x86emuOp_push_SI(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tESI\n");
@@ -3966,6 +4063,7 @@
 ****************************************************************************/
 static void x86emuOp_push_DI(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tEDI\n");
@@ -3988,6 +4086,7 @@
 ****************************************************************************/
 static void x86emuOp_pop_AX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tEAX\n");
@@ -4010,6 +4109,7 @@
 ****************************************************************************/
 static void x86emuOp_pop_CX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tECX\n");
@@ -4032,6 +4132,7 @@
 ****************************************************************************/
 static void x86emuOp_pop_DX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tEDX\n");
@@ -4054,6 +4155,7 @@
 ****************************************************************************/
 static void x86emuOp_pop_BX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tEBX\n");
@@ -4076,6 +4178,7 @@
 ****************************************************************************/
 static void x86emuOp_pop_SP(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tESP\n");
@@ -4098,6 +4201,7 @@
 ****************************************************************************/
 static void x86emuOp_pop_BP(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tEBP\n");
@@ -4120,6 +4224,7 @@
 ****************************************************************************/
 static void x86emuOp_pop_SI(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tESI\n");
@@ -4142,6 +4247,7 @@
 ****************************************************************************/
 static void x86emuOp_pop_DI(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tEDI\n");
@@ -4164,6 +4270,7 @@
 ****************************************************************************/
 static void x86emuOp_push_all(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSHAD\n");
@@ -4204,6 +4311,7 @@
 ****************************************************************************/
 static void x86emuOp_pop_all(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POPAD\n");
@@ -4243,6 +4351,7 @@
 ****************************************************************************/
 static void x86emuOp_segovr_FS(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("FS:\n");
     TRACE_AND_STEP();
@@ -4260,6 +4369,7 @@
 ****************************************************************************/
 static void x86emuOp_segovr_GS(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("GS:\n");
     TRACE_AND_STEP();
@@ -4277,6 +4387,7 @@
 ****************************************************************************/
 static void x86emuOp_prefix_data(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("DATA:\n");
     TRACE_AND_STEP();
@@ -4291,6 +4402,7 @@
 ****************************************************************************/
 static void x86emuOp_prefix_addr(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("ADDR:\n");
     TRACE_AND_STEP();
@@ -4307,6 +4419,7 @@
 {
     u32 imm;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         imm = fetch_long_imm();
@@ -4333,6 +4446,7 @@
     int mod, rl, rh;
     uint srcoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("IMUL\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -4533,6 +4647,7 @@
 {
     s16 imm;
 
+    DprintLn("");
     START_OF_INSTR();
     imm = (s8)fetch_byte_imm();
     DECODE_PRINTF2("PUSH\t%d\n", imm);
@@ -4556,6 +4671,7 @@
     uint srcoffset;
     s8  imm;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("IMUL\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -4746,6 +4862,7 @@
 ****************************************************************************/
 static void x86emuOp_ins_byte(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("INSB\n");
     ins(1);
@@ -4760,6 +4877,7 @@
 ****************************************************************************/
 static void x86emuOp_ins_word(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INSD\n");
@@ -4779,6 +4897,7 @@
 ****************************************************************************/
 static void x86emuOp_outs_byte(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("OUTSB\n");
     outs(1);
@@ -4793,6 +4912,7 @@
 ****************************************************************************/
 static void x86emuOp_outs_word(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("OUTSD\n");
@@ -4815,6 +4935,7 @@
     s8 offset;
     u16 target;
 
+    DprintLn("");
     /* jump to byte offset if overflow flag is set */
     START_OF_INSTR();
     DECODE_PRINTF("JO\t");
@@ -4837,6 +4958,7 @@
     s8 offset;
     u16 target;
 
+    DprintLn("");
     /* jump to byte offset if overflow is not set */
     START_OF_INSTR();
     DECODE_PRINTF("JNO\t");
@@ -4859,6 +4981,7 @@
     s8 offset;
     u16 target;
 
+    DprintLn("");
     /* jump to byte offset if carry flag is set. */
     START_OF_INSTR();
     DECODE_PRINTF("JB\t");
@@ -4881,6 +5004,7 @@
     s8 offset;
     u16 target;
 
+    DprintLn("");
     /* jump to byte offset if carry flag is clear. */
     START_OF_INSTR();
     DECODE_PRINTF("JNB\t");
@@ -4903,6 +5027,7 @@
     s8 offset;
     u16 target;
 
+    DprintLn("");
     /* jump to byte offset if zero flag is set. */
     START_OF_INSTR();
     DECODE_PRINTF("JZ\t");
@@ -4925,6 +5050,7 @@
     s8 offset;
     u16 target;
 
+    DprintLn("");
     /* jump to byte offset if zero flag is clear. */
     START_OF_INSTR();
     DECODE_PRINTF("JNZ\t");
@@ -4947,6 +5073,7 @@
     s8 offset;
     u16 target;
 
+    DprintLn("");
     /* jump to byte offset if carry flag is set or if the zero
        flag is set. */
     START_OF_INSTR();
@@ -4970,6 +5097,7 @@
     s8 offset;
     u16 target;
 
+    DprintLn("");
     /* jump to byte offset if carry flag is clear and if the zero
        flag is clear */
     START_OF_INSTR();
@@ -4993,6 +5121,7 @@
     s8 offset;
     u16 target;
 
+    DprintLn("");
     /* jump to byte offset if sign flag is set */
     START_OF_INSTR();
     DECODE_PRINTF("JS\t");
@@ -5015,6 +5144,7 @@
     s8 offset;
     u16 target;
 
+    DprintLn("");
     /* jump to byte offset if sign flag is clear */
     START_OF_INSTR();
     DECODE_PRINTF("JNS\t");
@@ -5037,6 +5167,7 @@
     s8 offset;
     u16 target;
 
+    DprintLn("");
     /* jump to byte offset if parity flag is set (even parity) */
     START_OF_INSTR();
     DECODE_PRINTF("JP\t");
@@ -5059,6 +5190,7 @@
     s8 offset;
     u16 target;
 
+    DprintLn("");
     /* jump to byte offset if parity flag is clear (odd parity) */
     START_OF_INSTR();
     DECODE_PRINTF("JNP\t");
@@ -5082,6 +5214,7 @@
     u16 target;
     int sf, of;
 
+    DprintLn("");
     /* jump to byte offset if sign flag not equal to overflow flag. */
     START_OF_INSTR();
     DECODE_PRINTF("JL\t");
@@ -5107,6 +5240,7 @@
     u16 target;
     int sf, of;
 
+    DprintLn("");
     /* jump to byte offset if sign flag not equal to overflow flag. */
     START_OF_INSTR();
     DECODE_PRINTF("JNL\t");
@@ -5133,6 +5267,7 @@
     u16 target;
     int sf, of;
 
+    DprintLn("");
     /* jump to byte offset if sign flag not equal to overflow flag
        or the zero flag is set */
     START_OF_INSTR();
@@ -5159,6 +5294,7 @@
     u16 target;
     int sf, of;
 
+    DprintLn("");
     /* jump to byte offset if sign flag equal to overflow flag.
        and the zero flag is clear */
     START_OF_INSTR();
@@ -5199,6 +5335,7 @@
     u8 imm;
     u8 destval;
 
+    DprintLn("");
     /*
      * Weirdo special case instruction format.  Part of the opcode
      * held below in "RH".  Doubly nested case would result, except
@@ -5328,6 +5465,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     /*
      * Weirdo special case instruction format.  Part of the opcode
      * held below in "RH".  Doubly nested case would result, except
@@ -5518,6 +5656,7 @@
     u8 imm;
     u8 destval;
 
+    DprintLn("");
     /*
      * Weirdo special case instruction format.  Part of the opcode
      * held below in "RH".  Doubly nested case would result, except
@@ -5643,6 +5782,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     /*
      * Weirdo special case instruction format.  Part of the opcode
      * held below in "RH".  Doubly nested case would result, except
@@ -5810,6 +5950,7 @@
     uint destoffset;
     u8 destval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("TEST\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -5863,6 +6004,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("TEST\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -5980,6 +6122,7 @@
     u8 destval;
     u8 tmp;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("XCHG\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -6044,6 +6187,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("XCHG\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -6183,6 +6327,7 @@
     u8 *destreg, *srcreg;
     uint destoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -6233,6 +6378,7 @@
     int mod, rl, rh;
     u32 destoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -6337,6 +6483,7 @@
     uint srcoffset;
     u8 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -6390,6 +6537,7 @@
     int mod, rl, rh;
     uint srcoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -6506,6 +6654,7 @@
     uint destoffset;
     u16 destval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -6566,6 +6715,7 @@
  * lea  eax,[eax+ebx*2] ??
  */
     
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("LEA\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -6613,6 +6763,7 @@
     uint srcoffset;
     u16 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -6672,6 +6823,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("POP\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -6765,6 +6917,7 @@
 ****************************************************************************/
 static void x86emuOp_nop(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("NOP\n");
     TRACE_AND_STEP();
@@ -6780,6 +6933,7 @@
 {
     u32 tmp;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XCHG\tEAX,ECX\n");
@@ -6808,6 +6962,7 @@
 {
     u32 tmp;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XCHG\tEAX,EDX\n");
@@ -6836,6 +6991,7 @@
 {
     u32 tmp;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XCHG\tEAX,EBX\n");
@@ -6864,6 +7020,7 @@
 {
     u32 tmp;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XCHG\tEAX,ESP\n");
@@ -6892,6 +7049,7 @@
 {
     u32 tmp;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XCHG\tEAX,EBP\n");
@@ -6920,6 +7078,7 @@
 {
     u32 tmp;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XCHG\tEAX,ESI\n");
@@ -6948,6 +7107,7 @@
 {
     u32 tmp;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XCHG\tEAX,EDI\n");
@@ -6974,6 +7134,7 @@
 ****************************************************************************/
 static void x86emuOp_cbw(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("CWDE\n");
@@ -7004,6 +7165,7 @@
 ****************************************************************************/
 static void x86emuOp_cwd(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("CDQ\n");
@@ -7037,6 +7199,7 @@
 {
     u16 farseg, faroff;
 
+    DprintLn("");
     START_OF_INSTR();
 	DECODE_PRINTF("CALL\t");
 	faroff = fetch_word_imm();
@@ -7066,6 +7229,7 @@
 ****************************************************************************/
 static void x86emuOp_wait(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("WAIT");
     TRACE_AND_STEP();
@@ -7082,6 +7246,7 @@
 {
     u32 flags;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSHFD\n");
@@ -7107,6 +7272,7 @@
 ****************************************************************************/
 static void x86emuOp_popf_word(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POPFD\n");
@@ -7129,6 +7295,7 @@
 ****************************************************************************/
 static void x86emuOp_sahf(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("SAHF\n");
     TRACE_AND_STEP();
@@ -7146,6 +7313,7 @@
 ****************************************************************************/
 static void x86emuOp_lahf(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("LAHF\n");
     TRACE_AND_STEP();
@@ -7165,6 +7333,7 @@
 {
     u16 offset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\tAL,");
     offset = fetch_word_imm();
@@ -7183,6 +7352,7 @@
 {
     u16 offset;
 
+    DprintLn("");
     START_OF_INSTR();
     offset = fetch_word_imm();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
@@ -7208,6 +7378,7 @@
 {
     u16 offset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\t");
     offset = fetch_word_imm();
@@ -7226,6 +7397,7 @@
 {
     u16 offset;
 
+    DprintLn("");
     START_OF_INSTR();
     offset = fetch_word_imm();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
@@ -7253,6 +7425,7 @@
     u32 count;
     int inc;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOVS\tBYTE\n");
     if (ACCESS_FLAG(F_DF))   /* down */
@@ -7288,6 +7461,7 @@
     int inc;
     u32 count;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOVS\tDWORD\n");
@@ -7335,6 +7509,7 @@
     s8 val1, val2;
     int inc;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("CMPS\tBYTE\n");
     TRACE_AND_STEP();
@@ -7391,6 +7566,7 @@
     u32 val1,val2;
     int inc;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("CMPS\tDWORD\n");
@@ -7471,6 +7647,7 @@
 {
     int imm;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("TEST\tAL,");
     imm = fetch_byte_imm();
@@ -7489,6 +7666,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("TEST\tEAX,");
@@ -7516,6 +7694,7 @@
 {
     int inc;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("STOS\tBYTE\n");
     if (ACCESS_FLAG(F_DF))   /* down */
@@ -7549,6 +7728,7 @@
     int inc;
     u32 count;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("STOS\tDWORD\n");
@@ -7592,6 +7772,7 @@
 {
     int inc;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("LODS\tBYTE\n");
     TRACE_AND_STEP();
@@ -7625,6 +7806,7 @@
     int inc;
     u32 count;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("LODS\tDWORD\n");
@@ -7669,6 +7851,7 @@
     s8 val2;
     int inc;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("SCAS\tBYTE\n");
     TRACE_AND_STEP();
@@ -7718,6 +7901,7 @@
     int inc;
     u32 val;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("SCAS\tDWORD\n");
@@ -7789,6 +7973,7 @@
 {
     u8 imm;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\tAL,");
     imm = fetch_byte_imm();
@@ -7807,6 +7992,7 @@
 {
     u8 imm;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\tCL,");
     imm = fetch_byte_imm();
@@ -7825,6 +8011,7 @@
 {
     u8 imm;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\tDL,");
     imm = fetch_byte_imm();
@@ -7843,6 +8030,7 @@
 {
     u8 imm;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\tBL,");
     imm = fetch_byte_imm();
@@ -7861,6 +8049,7 @@
 {
     u8 imm;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\tAH,");
     imm = fetch_byte_imm();
@@ -7879,6 +8068,7 @@
 {
     u8 imm;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\tCH,");
     imm = fetch_byte_imm();
@@ -7897,6 +8087,7 @@
 {
     u8 imm;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\tDH,");
     imm = fetch_byte_imm();
@@ -7915,6 +8106,7 @@
 {
     u8 imm;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\tBH,");
     imm = fetch_byte_imm();
@@ -7933,6 +8125,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tEAX,");
@@ -7960,6 +8153,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tECX,");
@@ -7987,6 +8181,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tEDX,");
@@ -8014,6 +8209,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tEBX,");
@@ -8041,6 +8237,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tESP,");
@@ -8068,6 +8265,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tEBP,");
@@ -8095,6 +8293,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tESI,");
@@ -8122,6 +8321,7 @@
 {
     u32 srcval;
 
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tEDI,");
@@ -8166,6 +8366,7 @@
     u8 destval;
     u8 amt;
 
+    DprintLn("");
     /*
      * Yet another weirdo special case instruction format.  Part of
      * the opcode held below in "RH".  Doubly nested case would
@@ -8290,6 +8491,7 @@
     uint destoffset;
     u8 amt;
 
+    DprintLn("");
     /*
      * Yet another weirdo special case instruction format.  Part of
      * the opcode held below in "RH".  Doubly nested case would
@@ -8442,6 +8644,7 @@
 {
     u16 imm;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("RET\t");
     imm = fetch_word_imm();
@@ -8460,6 +8663,7 @@
 ****************************************************************************/
 static void x86emuOp_ret_near(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("RET\n");
 	RETURN_TRACE("RET",M.x86.saved_cs,M.x86.saved_ip);
@@ -8479,6 +8683,7 @@
     u16 *dstreg;
     uint srcoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("LES\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -8528,6 +8733,7 @@
     u16 *dstreg;
     uint srcoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("LDS\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -8578,6 +8784,7 @@
     uint destoffset;
     u8 imm;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -8631,6 +8838,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("MOV\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -8738,6 +8946,7 @@
     u8  nesting;
     int i;
 
+    DprintLn("");
     START_OF_INSTR();
     local = fetch_word_imm();
     nesting = fetch_byte_imm();
@@ -8765,6 +8974,7 @@
 ****************************************************************************/
 static void x86emuOp_leave(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("LEAVE\n");
     TRACE_AND_STEP();
@@ -8782,6 +8992,7 @@
 {
     u16 imm;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("RETF\t");
     imm = fetch_word_imm();
@@ -8801,6 +9012,7 @@
 ****************************************************************************/
 static void x86emuOp_ret_far(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("RETF\n");
 	RETURN_TRACE("RETF",M.x86.saved_cs,M.x86.saved_ip);
@@ -8817,6 +9029,7 @@
 ****************************************************************************/
 static void x86emuOp_int3(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("INT 3\n");
     TRACE_AND_STEP();
@@ -8843,6 +9056,7 @@
 {
     u8 intnum;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("INT\t");
     intnum = fetch_byte_imm();
@@ -8869,6 +9083,7 @@
 ****************************************************************************/
 static void x86emuOp_into(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("INTO\n");
     TRACE_AND_STEP();
@@ -8895,6 +9110,7 @@
 ****************************************************************************/
 static void x86emuOp_iret(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("IRET\n");
 
@@ -8918,6 +9134,7 @@
     uint destoffset;
     u8 destval;
 
+    DprintLn("");
     /*
      * Yet another weirdo special case instruction format.  Part of
      * the opcode held below in "RH".  Doubly nested case would
@@ -9010,6 +9227,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     /*
      * Yet another weirdo special case instruction format.  Part of
      * the opcode held below in "RH".  Doubly nested case would
@@ -9161,6 +9379,7 @@
     u8 destval;
     u8 amt;
 
+    DprintLn("");
     /*
      * Yet another weirdo special case instruction format.  Part of
      * the opcode held below in "RH".  Doubly nested case would
@@ -9255,6 +9474,7 @@
     uint destoffset;
     u8 amt;
 
+    DprintLn("");
     /*
      * Yet another weirdo special case instruction format.  Part of
      * the opcode held below in "RH".  Doubly nested case would
@@ -9399,6 +9619,7 @@
 {
     u8 a;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("AAM\n");
     a = fetch_byte_imm();      /* this is a stupid encoding. */
@@ -9420,6 +9641,7 @@
 ****************************************************************************/
 static void x86emuOp_aad(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("AAD\n");
     (void) fetch_byte_imm();
@@ -9439,6 +9661,7 @@
 {
     u16 addr;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("XLAT\n");
     TRACE_AND_STEP();
@@ -9458,6 +9681,7 @@
 {
     s16 ip;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("LOOPNE\t");
     ip = (s8) fetch_byte_imm();
@@ -9479,6 +9703,7 @@
 {
     s16 ip;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("LOOPE\t");
     ip = (s8) fetch_byte_imm();
@@ -9500,6 +9725,7 @@
 {
     s16 ip;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("LOOP\t");
     ip = (s8) fetch_byte_imm();
@@ -9522,6 +9748,7 @@
     u16 target;
     s8  offset;
 
+    DprintLn("");
     /* jump to byte offset if overflow flag is set */
     START_OF_INSTR();
     DECODE_PRINTF("JCXZ\t");
@@ -9543,6 +9770,7 @@
 {
     u8 port;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("IN\t");
 	port = (u8) fetch_byte_imm();
@@ -9561,6 +9789,7 @@
 {
     u8 port;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("IN\t");
 	port = (u8) fetch_byte_imm();
@@ -9587,6 +9816,7 @@
 {
     u8 port;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("OUT\t");
 	port = (u8) fetch_byte_imm();
@@ -9605,6 +9835,7 @@
 {
     u8 port;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("OUT\t");
 	port = (u8) fetch_byte_imm();
@@ -9631,6 +9862,7 @@
 {
     s16 ip;
 
+    DprintLn("");
     START_OF_INSTR();
 	DECODE_PRINTF("CALL\t");
 	ip = (s16) fetch_word_imm();
@@ -9652,6 +9884,7 @@
 {
     int ip;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("JMP\t");
     ip = (s16)fetch_word_imm();
@@ -9671,6 +9904,7 @@
 {
     u16 cs, ip;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("JMP\tFAR ");
     ip = fetch_word_imm();
@@ -9693,6 +9927,7 @@
     u16 target;
     s8 offset;
 
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("JMP\t");
     offset = (s8)fetch_byte_imm();
@@ -9710,6 +9945,7 @@
 ****************************************************************************/
 static void x86emuOp_in_byte_AL_DX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("IN\tAL,DX\n");
     TRACE_AND_STEP();
@@ -9724,6 +9960,7 @@
 ****************************************************************************/
 static void x86emuOp_in_word_AX_DX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("IN\tEAX,DX\n");
@@ -9746,6 +9983,7 @@
 ****************************************************************************/
 static void x86emuOp_out_byte_DX_AL(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("OUT\tDX,AL\n");
     TRACE_AND_STEP();
@@ -9760,6 +9998,7 @@
 ****************************************************************************/
 static void x86emuOp_out_word_DX_AX(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("OUT\tDX,EAX\n");
@@ -9782,6 +10021,7 @@
 ****************************************************************************/
 static void x86emuOp_lock(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("LOCK:\n");
     TRACE_AND_STEP();
@@ -9797,6 +10037,7 @@
 ****************************************************************************/
 static void x86emuOp_repne(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("REPNE\n");
     TRACE_AND_STEP();
@@ -9811,6 +10052,7 @@
 ****************************************************************************/
 static void x86emuOp_repe(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("REPE\n");
     TRACE_AND_STEP();
@@ -9825,6 +10067,7 @@
 ****************************************************************************/
 static void x86emuOp_halt(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     START_OF_INSTR();
     DECODE_PRINTF("HALT\n");
     TRACE_AND_STEP();
@@ -9839,6 +10082,7 @@
 ****************************************************************************/
 static void x86emuOp_cmc(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     /* complement the carry flag. */
     START_OF_INSTR();
     DECODE_PRINTF("CMC\n");
@@ -9859,6 +10103,7 @@
     uint destoffset;
     u8 destval, srcval;
 
+    DprintLn("");
     /* long, drawn out code follows.  Double switch for a total
        of 32 cases.  */
     START_OF_INSTR();
@@ -10141,6 +10386,7 @@
     int mod, rl, rh;
     uint destoffset;
 
+    DprintLn("");
     /* long, drawn out code follows.  Double switch for a total
        of 32 cases.  */
     START_OF_INSTR();
@@ -10793,6 +11039,7 @@
 ****************************************************************************/
 static void x86emuOp_clc(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     /* clear the carry flag. */
     START_OF_INSTR();
     DECODE_PRINTF("CLC\n");
@@ -10808,6 +11055,7 @@
 ****************************************************************************/
 static void x86emuOp_stc(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     /* set the carry flag. */
     START_OF_INSTR();
     DECODE_PRINTF("STC\n");
@@ -10823,6 +11071,7 @@
 ****************************************************************************/
 static void x86emuOp_cli(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     /* clear interrupts. */
     START_OF_INSTR();
     DECODE_PRINTF("CLI\n");
@@ -10838,6 +11087,7 @@
 ****************************************************************************/
 static void x86emuOp_sti(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     /* enable  interrupts. */
     START_OF_INSTR();
     DECODE_PRINTF("STI\n");
@@ -10853,6 +11103,7 @@
 ****************************************************************************/
 static void x86emuOp_cld(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     /* clear interrupts. */
     START_OF_INSTR();
     DECODE_PRINTF("CLD\n");
@@ -10868,6 +11119,7 @@
 ****************************************************************************/
 static void x86emuOp_std(u8 X86EMU_UNUSED(op1))
 {
+    DprintLn("");
     /* clear interrupts. */
     START_OF_INSTR();
     DECODE_PRINTF("STD\n");
@@ -10888,6 +11140,7 @@
     uint destoffset;
     u8 *destreg;
 
+    DprintLn("");
     /* Yet another special case instruction. */
     START_OF_INSTR();
     FETCH_DECODE_MODRM(mod, rh, rl);
@@ -11005,6 +11258,7 @@
 	u16 *destreg;
 	u16 destval,destval2;
 
+    DprintLn("");
     /* Yet another special case instruction. */
     START_OF_INSTR();
     FETCH_DECODE_MODRM(mod, rh, rl);
--- libx86-1.1/x86emu/debug.c.SAVE	2006-10-30 17:28:48.000000000 +0300
+++ libx86-1.1/x86emu/debug.c	2009-04-12 13:33:09.000000000 +0400
@@ -45,6 +45,14 @@
 #include <stdlib.h>
 #endif
 
+#include <stdio.h>
+
+#define DprintLn(fmt, args...) \
+    do { \
+       fprintf(stderr, "[%s:%u:%s] " fmt "\n", __FUNCTION__, __LINE__, __FILE__, ##args); \
+       fflush(stderr); \
+    } while (0)
+
 /*----------------------------- Implementation ----------------------------*/
 
 #ifdef DEBUG
@@ -56,7 +64,8 @@
 /* should look something like debug's output. */
 void X86EMU_trace_regs (void)
 {
-return;
+    DprintLn("");
+//return;
 	if (DEBUG_TRACE()) {
 		x86emu_dump_regs();
     }
@@ -72,6 +81,7 @@
 
 void X86EMU_trace_xregs (void)
 {
+    DprintLn("");
 	if (DEBUG_TRACE()) {
 		x86emu_dump_xregs();
     }
@@ -79,6 +89,7 @@
 
 void x86emu_just_disassemble (void)
 {
+    DprintLn("");
     /*
      * This routine called if the flag DEBUG_DISASSEMBLE is set kind
      * of a hack!
@@ -93,6 +104,7 @@
 	X86EMU_sysEnv tregs;
 	int i;
 	u8 op1;
+    DprintLn("");
     /*
      * hack, hack, hack.  What we do is use the exact machinery set up
      * for execution, except that now there is an additional state
@@ -145,31 +157,37 @@
 
 void x86emu_check_ip_access (void)
 {
+    DprintLn("");
     /* NULL as of now */
 }
 
 void x86emu_check_sp_access (void)
 {
+    DprintLn("");
 }
 
 void x86emu_check_mem_access (u32 dummy)
 {
+    DprintLn("");
 	/*  check bounds, etc */
 }
 
 void x86emu_check_data_access (uint dummy1, uint dummy2)
 {
+    DprintLn("");
 	/*  check bounds, etc */
 }
 
 void x86emu_inc_decoded_inst_len (int x)
 {
+    DprintLn("");
 	M.x86.enc_pos += x;
 }
 
 void x86emu_decode_printf (char *x)
 {
 	sprintf(M.x86.decoded_buf+M.x86.enc_str_pos,"%s",x);
+	fputs(x, stderr); fflush(stderr);
 	M.x86.enc_str_pos += strlen(x);
 }
 
@@ -178,11 +196,13 @@
 	char temp[100];
 	sprintf(temp,x,y);
 	sprintf(M.x86.decoded_buf+M.x86.enc_str_pos,"%s",temp);
+	fputs(temp, stderr); fflush(stderr);
 	M.x86.enc_str_pos += strlen(temp);
 }
 
 void x86emu_end_instr (void)
 {
+    DprintLn("");
 	M.x86.enc_str_pos = 0;
 	M.x86.enc_pos = 0;
 }
@@ -194,11 +214,13 @@
 	for (i=0; i< M.x86.enc_pos; i++) {
 		sprintf(buf1+2*i,"%02x", fetch_data_byte_abs(s,o+i));
     }
+    DprintLn("%-20s",buf1);
 	printf("%-20s",buf1);
 }
 
 static void print_decoded_instruction (void)
 {
+    DprintLn("%s", M.x86.decoded_buf);
 	printf("%s", M.x86.decoded_buf);
 }
 
@@ -206,9 +228,11 @@
 {
 	u16 seg,off;
 
+    DprintLn("");
 	if (iv > 256) return;
 	seg   = fetch_data_word_abs(0,iv*4);
 	off   = fetch_data_word_abs(0,iv*4+2);
+    DprintLn("%04x:%04x ", seg, off);
 	printf("%04x:%04x ", seg, off);
 }
 
@@ -219,6 +243,7 @@
 	u32 i;
 	u32 current;
 
+    DprintLn("");
 	current = start;
 	while (end <= off + amt) {
 		printf("%04x:%04x ", seg, start);
@@ -246,6 +271,7 @@
     
     char *p;
 
+    DprintLn("");
 		if (DEBUG_BREAK()) {
 				if (M.x86.saved_ip != breakpoint) {
 						return;
@@ -325,11 +351,13 @@
 
 int X86EMU_trace_on(void)
 {
+    DprintLn("");
 	return M.x86.debug |= DEBUG_STEP_F | DEBUG_DECODE_F | DEBUG_TRACE_F;
 }
 
 int X86EMU_trace_off(void)
 {
+    DprintLn("");
 	return M.x86.debug &= ~(DEBUG_STEP_F | DEBUG_DECODE_F | DEBUG_TRACE_F);
 }
 
@@ -337,6 +365,7 @@
 {
     int cmd;
 
+    DprintLn("");
     *n = 0;
     while(*s == ' ' || *s == '\t') s++;
     ps[*n] = *s;
@@ -366,6 +395,7 @@
 
 void x86emu_dump_regs (void)
 {
+    DprintLn("");
 	fprintf(stderr, "\tAX=%04x  ", M.x86.R_AX );
 	fprintf(stderr, "BX=%04x  ", M.x86.R_BX );
 	fprintf(stderr, "CX=%04x  ", M.x86.R_CX );
@@ -400,6 +430,7 @@
 
 void x86emu_dump_xregs (void)
 {
+    DprintLn("");
 	printf("\tEAX=%08x  ", M.x86.R_EAX );
 	printf("EBX=%08x  ", M.x86.R_EBX );
 	printf("ECX=%08x  ", M.x86.R_ECX );
--- libx86-1.1/x86emu/decode.c.SAVE	2006-10-30 23:42:27.000000000 +0300
+++ libx86-1.1/x86emu/decode.c	2009-04-12 15:52:01.000000000 +0400
@@ -40,6 +40,13 @@
 
 #include "x86emu/x86emui.h"
 
+#include <stdio.h>
+#define DprintLn(fmt, args...) \
+    do { \
+       fprintf(stderr, "[%s:%u:%s] " fmt "\n", __FUNCTION__, __LINE__, __FILE__, ##args); \
+       fflush(stderr); \
+    } while (0)
+
 /*----------------------------- Implementation ----------------------------*/
 
 /****************************************************************************
@@ -50,6 +57,7 @@
 {
 	u8	intno;
 
+    DprintLn("");
 	if (M.x86.intr & INTR_SYNCH) {
 		intno = M.x86.intno;
 		if (_X86EMU_intrTab[intno]) {
@@ -78,6 +86,7 @@
 void x86emu_intr_raise(
 	u8 intrnum)
 {
+    DprintLn("");
 	M.x86.intno = intrnum;
 	M.x86.intr |= INTR_SYNCH;
 }
@@ -96,6 +105,7 @@
 	DB(x86emu_end_instr();)
 
     for (;;) {
+        DprintLn("CS:IP=%04X:%08X", M.x86.R_CS, M.x86.R_IP);
 DB(		if (CHECK_IP_FETCH())
 		  x86emu_check_ip_access();)
 		/* If debugging, save the IP and CS values. */
@@ -121,6 +131,7 @@
 		op1 = (*sys_rdb)(((u32)M.x86.R_CS << 4) + (M.x86.R_IP++));
 		//		fprintf (stderr, "%s", M.x86.decoded_buf);
 		//		x86emu_dump_regs();
+        DprintLn("x86emu_optab[%u]=%p", op1, x86emu_optab[op1]);
 		(*x86emu_optab[op1])(op1);
     }
 }
@@ -131,6 +142,7 @@
 ****************************************************************************/
 void X86EMU_halt_sys(void)
 {
+    DprintLn("");
 	M.x86.intr |= INTR_HALTED;
 }
 
@@ -153,6 +165,7 @@
 {
 	int fetched;
 
+    DprintLn("");
 DB(	if (CHECK_IP_FETCH())
 	  x86emu_check_ip_access();)
 	fetched = (*sys_rdb)(((u32)M.x86.R_CS << 4) + (M.x86.R_IP++));
@@ -176,6 +189,7 @@
 {
 	u8 fetched;
 
+    DprintLn("");
 DB(	if (CHECK_IP_FETCH())
 		x86emu_check_ip_access();)
 	fetched = (*sys_rdb)(((u32)M.x86.R_CS << 4) + (M.x86.R_IP++));
@@ -197,6 +211,7 @@
 {
 	u16	fetched;
 
+    DprintLn("");
 DB(	if (CHECK_IP_FETCH())
 		x86emu_check_ip_access();)
 	fetched = (*sys_rdw)(((u32)M.x86.R_CS << 4) + (M.x86.R_IP));
@@ -219,6 +234,7 @@
 {
 	u32 fetched;
 
+    DprintLn("");
 DB(	if (CHECK_IP_FETCH())
 	  x86emu_check_ip_access();)
 	fetched = (*sys_rdl)(((u32)M.x86.R_CS << 4) + (M.x86.R_IP));
@@ -302,6 +318,7 @@
 u8 fetch_data_byte(
 	uint offset)
 {
+    DprintLn("");
 #ifdef DEBUG
 	if (CHECK_DATA_ACCESS())
 		x86emu_check_data_access((u16)get_data_segment(), offset);
@@ -321,6 +338,7 @@
 u16 fetch_data_word(
 	uint offset)
 {
+    DprintLn("");
 #ifdef DEBUG
 	if (CHECK_DATA_ACCESS())
 		x86emu_check_data_access((u16)get_data_segment(), offset);
@@ -340,6 +358,7 @@
 u32 fetch_data_long(
 	uint offset)
 {
+    DprintLn("");
 #ifdef DEBUG
 	if (CHECK_DATA_ACCESS())
 		x86emu_check_data_access((u16)get_data_segment(), offset);
@@ -361,6 +380,7 @@
 	uint segment,
 	uint offset)
 {
+    DprintLn("");
 #ifdef DEBUG
 	if (CHECK_DATA_ACCESS())
 		x86emu_check_data_access(segment, offset);
@@ -382,6 +402,7 @@
 	uint segment,
 	uint offset)
 {
+    DprintLn("");
 #ifdef DEBUG
 	if (CHECK_DATA_ACCESS())
 		x86emu_check_data_access(segment, offset);
@@ -403,6 +424,7 @@
 	uint segment,
 	uint offset)
 {
+    DprintLn("");
 #ifdef DEBUG
 	if (CHECK_DATA_ACCESS())
 		x86emu_check_data_access(segment, offset);
@@ -425,6 +447,7 @@
 	uint offset,
 	u8 val)
 {
+    DprintLn("");
 #ifdef DEBUG
 	if (CHECK_DATA_ACCESS())
 		x86emu_check_data_access((u16)get_data_segment(), offset);
@@ -447,6 +470,7 @@
 	uint offset,
 	u16 val)
 {
+    DprintLn("");
 #ifdef DEBUG
 	if (CHECK_DATA_ACCESS())
 		x86emu_check_data_access((u16)get_data_segment(), offset);
@@ -469,6 +493,7 @@
 	uint offset,
 	u32 val)
 {
+    DprintLn("");
 #ifdef DEBUG
 	if (CHECK_DATA_ACCESS())
 		x86emu_check_data_access((u16)get_data_segment(), offset);
@@ -492,6 +517,7 @@
 	uint offset,
 	u8 val)
 {
+    DprintLn("");
 #ifdef DEBUG
 	if (CHECK_DATA_ACCESS())
 		x86emu_check_data_access(segment, offset);
@@ -515,6 +541,7 @@
 	uint offset,
 	u16 val)
 {
+    DprintLn("");
 #ifdef DEBUG
 	if (CHECK_DATA_ACCESS())
 		x86emu_check_data_access(segment, offset);
@@ -538,6 +565,7 @@
 	uint offset,
 	u32 val)
 {
+    DprintLn("");
 #ifdef DEBUG
 	if (CHECK_DATA_ACCESS())
 		x86emu_check_data_access(segment, offset);
@@ -559,6 +587,7 @@
 u8* decode_rm_byte_register(
 	int reg)
 {
+    DprintLn("");
 	switch (reg) {
       case 0:
 		DECODE_PRINTF("AL");
@@ -603,6 +632,7 @@
 u16* decode_rm_word_register(
 	int reg)
 {
+    DprintLn("");
 	switch (reg) {
 	  case 0:
 		DECODE_PRINTF("AX");
@@ -647,6 +677,7 @@
 u32* decode_rm_long_register(
 	int reg)
 {
+    DprintLn("");
     switch (reg) {
       case 0:
 		DECODE_PRINTF("EAX");
@@ -692,6 +723,7 @@
 u16* decode_rm_seg_register(
 	int reg)
 {
+    DprintLn("");
 	switch (reg) {
 	  case 0:
 		DECODE_PRINTF("ES");
@@ -731,6 +763,7 @@
 {
     u32 base = 0, i = 0, scale = 1;
 
+    DprintLn("");
     switch(sib & 0x07) {
     case 0:
 	DECODE_PRINTF("[EAX]");
@@ -842,6 +875,7 @@
     u32 offset;
     int sib;
 
+    DprintLn("");
     if (M.x86.mode & SYSMODE_PREFIX_ADDR) {
 	switch (rm) {
 	  case 0:
@@ -923,6 +957,7 @@
     int displacement = 0;
     int sib;
 
+    DprintLn("");
     /* Fetch disp8 if no SIB byte */
     if (!((M.x86.mode & SYSMODE_PREFIX_ADDR) && (rm == 4)))
 	displacement = (s8)fetch_byte_imm();
@@ -1009,6 +1044,7 @@
     u32 displacement = 0;
     int sib;
 
+    DprintLn("");
     /* Fetch disp16 if 16-bit addr mode */
     if (!(M.x86.mode & SYSMODE_PREFIX_ADDR))
 	displacement = (u16)fetch_word_imm();
--- libx86-1.1/x86emu/prim_ops.c.SAVE	2008-03-22 05:20:15.000000000 +0300
+++ libx86-1.1/x86emu/prim_ops.c	2009-04-12 16:08:04.000000000 +0400
@@ -1,3 +1,10 @@
+#include <stdio.h>
+#define DprintLn(fmt, args...) \
+    do { \
+       fprintf(stderr, "[%s:%u:%s] " fmt "\n", __FUNCTION__, __LINE__, __FILE__, ##args); \
+       fflush(stderr); \
+    } while (0)
+
 /****************************************************************************
 *
 *						Realmode X86 Emulator Library
@@ -2599,6 +2606,7 @@
 ****************************************************************************/
 u16 mem_access_word(int addr)
 {
+    DprintLn("addr=%X", addr);
 DB(	if (CHECK_MEM_ACCESS())
 	  x86emu_check_mem_access(addr);)
 	return (*sys_rdw)(addr);
@@ -2612,10 +2620,13 @@
 ****************************************************************************/
 void push_word(u16 w)
 {
+    DprintLn("w=%04X", w);
 DB(	if (CHECK_SP_ACCESS())
 	  x86emu_check_sp_access();)
 	M.x86.R_SP -= 2;
+    DprintLn("SS:SP=%04X:%08X", M.x86.R_SS, M.x86.R_SP);
 	(*sys_wrw)(((u32)M.x86.R_SS << 4)  + M.x86.R_SP, w);
+    DprintLn("");
 }
 
 /****************************************************************************
@@ -2626,10 +2637,13 @@
 ****************************************************************************/
 void push_long(u32 w)
 {
+    DprintLn("w=%08X", w);
 DB(	if (CHECK_SP_ACCESS())
 	  x86emu_check_sp_access();)
 	M.x86.R_SP -= 4;
+    DprintLn("SS:SP=%04X:%08X", M.x86.R_SS, M.x86.R_SP);
 	(*sys_wrl)(((u32)M.x86.R_SS << 4)  + M.x86.R_SP, w);
+    DprintLn("");
 }
 
 /****************************************************************************
@@ -2641,6 +2655,7 @@
 u16 pop_word(void)
 {
 	register u16 res;
+    DprintLn("");
 
 DB(	if (CHECK_SP_ACCESS())
 	  x86emu_check_sp_access();)
@@ -2658,6 +2673,7 @@
 u32 pop_long(void)
 {
     register u32 res;
+    DprintLn("");
 
 DB(	if (CHECK_SP_ACCESS())
 	  x86emu_check_sp_access();)
@@ -2673,6 +2689,7 @@
 void cpuid (void)
 {
     u32 feature = M.x86.R_EAX;
+    DprintLn("");
 
 #ifdef X86EMU_HAS_HW_CPUID
     /* If the platform allows it, we will base our values on the real
--- libx86-1.1/x86emu/sys.c.SAVE	2007-09-24 04:15:57.000000000 +0400
+++ libx86-1.1/x86emu/sys.c	2009-04-12 16:26:13.000000000 +0400
@@ -56,6 +56,13 @@
 #include <fcntl.h>
 #include <sys/mman.h>
 
+#include <stdio.h>
+#define DprintLn(fmt, args...) \
+    do { \
+       fprintf(stderr, "[%s:%u:%s] " fmt "\n", __FUNCTION__, __LINE__, __FILE__, ##args); \
+       fflush(stderr); \
+    } while (0)
+
 /*------------------------- Global Variables ------------------------------*/
 
 X86EMU_sysEnv		_X86EMU_env;		/* Global emulator machine state */
@@ -85,6 +92,7 @@
 {
 #if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
 	const struct __una_u64 *ptr = (const struct __una_u64 *) r11;
+    DprintLn("");
 	return ptr->x;
 #else
 	unsigned long r1,r2;
@@ -96,6 +104,7 @@
 		:"r" (r11),
 		 "m" (*r11),
 		 "m" (*(const unsigned long *)(7+(char *) r11)));
+    DprintLn("");
 	return r1 | r2;
 #endif
 }
@@ -104,6 +113,7 @@
 {
 #if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
 	const struct __una_u32 *ptr = (const struct __una_u32 *) r11;
+    DprintLn("");
 	return ptr->x;
 #else
 	unsigned long r1,r2;
@@ -115,6 +125,7 @@
 		:"r" (r11),
 		 "m" (*r11),
 		 "m" (*(const unsigned long *)(3+(char *) r11)));
+    DprintLn("");
 	return r1 | r2;
 #endif
 }
@@ -123,6 +134,7 @@
 {
 #if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
 	const struct __una_u16 *ptr = (const struct __una_u16 *) r11;
+    DprintLn("");
 	return ptr->x;
 #else
 	unsigned long r1,r2;
@@ -134,6 +146,7 @@
 		:"r" (r11),
 		 "m" (*r11),
 		 "m" (*(const unsigned long *)(1+(char *) r11)));
+    DprintLn("");
 	return r1 | r2;
 #endif
 }
@@ -146,9 +159,11 @@
 {
 #if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
 	struct __una_u64 *ptr = (struct __una_u64 *) r11;
+    DprintLn("");
 	ptr->x = r5;
 #else
 	unsigned long r1,r2,r3,r4;
+    DprintLn("");
 
 	__asm__("ldq_u %3,%1\n\t"
 		"ldq_u %2,%0\n\t"
@@ -171,9 +186,11 @@
 {
 #if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
 	struct __una_u32 *ptr = (struct __una_u32 *) r11;
+    DprintLn("");
 	ptr->x = r5;
 #else
 	unsigned long r1,r2,r3,r4;
+    DprintLn("");
 
 	__asm__("ldq_u %3,%1\n\t"
 		"ldq_u %2,%0\n\t"
@@ -196,9 +213,11 @@
 {
 #if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
 	struct __una_u16 *ptr = (struct __una_u16 *) r11;
+    DprintLn("");
 	ptr->x = r5;
 #else
 	unsigned long r1,r2,r3,r4;
+    DprintLn("");
 
 	__asm__("ldq_u %3,%1\n\t"
 		"ldq_u %2,%0\n\t"
@@ -225,6 +244,7 @@
   void *identity = mmap(NULL, 8192, PROT_READ, MAP_PRIVATE, fd, (addr-offset));
   memcpy (&value, identity+offset, size);
   munmap (identity, 8192);
+    DprintLn("");
   return value;
 }
 
@@ -243,6 +263,7 @@
     u32 addr)
 {
 	u8 val;
+    DprintLn("");
 
 	if (addr > M.mem_size - 1)
 	  val = mmap_read (addr, 1);
@@ -250,6 +271,7 @@
 	  val = *(u8*)(M.mem_base + addr);	
 DB(	if (DEBUG_MEM_TRACE())
 		printk("%#08x 1 -> %#x\n", addr, val);)
+    DprintLn("[addr=%08X]=%02X", addr, val);
 	return val;
 }
 
@@ -267,6 +289,7 @@
 	u32 addr)
 {
 	u16 val = 0;
+    DprintLn("");
 
 	if (addr > M.mem_size - 2)
 	  val = mmap_read (addr, 2);
@@ -286,6 +309,7 @@
 	}
 	  DB(	if (DEBUG_MEM_TRACE())
 		printk("%#08x 2 -> %#x\n", addr, val);)
+    DprintLn("[addr=%08X]=%04X", addr, val);
     return val;
 }
 
@@ -302,6 +326,7 @@
 	u32 addr)
 {
 	u32 val = 0;
+    DprintLn("");
 
 	if (addr > M.mem_size - 4)
 	  val = mmap_read (addr, 4);
@@ -323,6 +348,7 @@
 	}
 	DB(	if (DEBUG_MEM_TRACE())
 		printk("%#08x 4 -> %#x\n", addr, val);)
+    DprintLn("[addr=%08X]=%08X", addr, val);
 	  return val;
 }
 
@@ -338,6 +364,7 @@
 	u32 addr,
 	u8 val)
 {
+    DprintLn("");
 DB(	if (DEBUG_MEM_TRACE())
 		printk("%#08x 1 <- %#x\n", addr, val);)
     if (addr > M.mem_size - 1) {
@@ -359,6 +386,7 @@
 	u32 addr,
 	u16 val)
 {
+    DprintLn("");
 DB(	if (DEBUG_MEM_TRACE())
 		printk("%#08x 2 <- %#x\n", addr, val);)
 	if (addr > M.mem_size - 2) {
@@ -391,6 +419,7 @@
 	u32 addr,
 	u32 val)
 {
+    DprintLn("");
 DB(	if (DEBUG_MEM_TRACE())
 		printk("%#08x 4 <- %#x\n", addr, val);)
 	if (addr > M.mem_size - 4) {
@@ -424,6 +453,7 @@
 static u8 X86API p_inb(
 	X86EMU_pioAddr addr)
 {
+    DprintLn("");
 	printf("No real inb\n");
 DB(	if (DEBUG_IO_TRACE())
 		printk("inb %#04x \n", addr);)
@@ -441,6 +471,7 @@
 static u16 X86API p_inw(
 	X86EMU_pioAddr addr)
 {
+    DprintLn("");
 	printf("No real inw\n");
 DB(	if (DEBUG_IO_TRACE())
 		printk("inw %#04x \n", addr);)
@@ -458,6 +489,7 @@
 static u32 X86API p_inl(
 	X86EMU_pioAddr addr)
 {
+    DprintLn("");
 	printf("No real inl\n");
 DB(	if (DEBUG_IO_TRACE())
 		printk("inl %#04x \n", addr);)
@@ -475,6 +507,7 @@
 	X86EMU_pioAddr addr,
 	u8 val)
 {
+    DprintLn("");
 	printf("No real outb\n");
 DB(	if (DEBUG_IO_TRACE())
 		printk("outb %#02x -> %#04x \n", val, addr);)
@@ -492,6 +525,7 @@
 	X86EMU_pioAddr addr,
 	u16 val)
 {
+    DprintLn("");
 	printf("No real outw\n");
 DB(	if (DEBUG_IO_TRACE())
 		printk("outw %#04x -> %#04x \n", val, addr);)
@@ -509,6 +543,7 @@
 	X86EMU_pioAddr addr,
 	u32 val)
 {
+    DprintLn("");
 	printf("No real outl\n");
 DB(	if (DEBUG_IO_TRACE())
 		printk("outl %#08x -> %#04x \n", val, addr);)
@@ -544,6 +579,7 @@
 void X86EMU_setupMemFuncs(
 	X86EMU_memFuncs *funcs)
 {
+    DprintLn("");
     sys_rdb = funcs->rdb;
     sys_rdw = funcs->rdw;
     sys_rdl = funcs->rdl;
@@ -564,6 +600,7 @@
 void X86EMU_setupPioFuncs(
 	X86EMU_pioFuncs *funcs)
 {
+    DprintLn("");
     sys_inb = funcs->inb;
     sys_inw = funcs->inw;
     sys_inl = funcs->inl;
@@ -589,6 +626,7 @@
 	X86EMU_intrFuncs funcs[])
 {
     int i;
+    DprintLn("");
     
 	for (i=0; i < 256; i++)
 		_X86EMU_intrTab[i] = NULL;
@@ -613,6 +651,7 @@
 void X86EMU_prepareForInt(
 	int num)
 {
+    DprintLn("");
     push_word((u16)M.x86.R_FLG);
     CLEAR_FLAG(F_IF);
     CLEAR_FLAG(F_TF);
@@ -621,4 +660,5 @@
     push_word(M.x86.R_IP);
     M.x86.R_IP = mem_access_word(num * 4);
 	M.x86.intr = 0;
+    DprintLn("");
 }
--- libx86-1.1/thunk.c.SAVE	2008-04-03 04:48:00.000000000 +0400
+++ libx86-1.1/thunk.c	2009-04-12 14:44:37.000000000 +0400
@@ -41,6 +41,13 @@
         return value; \
 }\
 
+#define DprintLn(fmt, args...) \
+    do { \
+	fprintf(stderr, "[%s:%u:%s] " fmt "\n", __FUNCTION__, __LINE__, __FILE__, ##args); \
+	fflush(stderr); \
+    } while (0)
+
+
 __BUILDIO(b,b,char)
 __BUILDIO(w,w,short)
 __BUILDIO(l,,int)
@@ -57,7 +64,7 @@
 	va_list argptr;
 	va_start(argptr, fmt);
 
-	fprintf(stderr, fmt, argptr);
+	vfprintf(stderr, fmt, argptr);
 	va_end(argptr);
 }
 
@@ -165,6 +172,7 @@
 	 * Allocate a 64k stack.
 	 */
 	stack = LRMI_alloc_real(64 * 1024);
+	DprintLn("stack=%p", stack);
 	X86_SS = (unsigned int) stack >> 4;
 	X86_ESP = 0xFFF9;
 	memset (stack, 0, 64*1024);
